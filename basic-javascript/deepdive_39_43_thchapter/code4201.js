/*
1.
실행 컨텍스트 스택에 함수 실행 컨텍스트가 푸쉬되는 것은 함수 실행 시작을 의미.
그리고, 자바스크립트 엔진은 단 하나의 실행 컨텍스트 스택을 가짐.
따라서, 자바스크립트 엔진은 한 번에 하나의 테스크만 실행 가능한
싱글 스레드(Single Thread) 방식으로 동작함.

싱글 스레드 방식은 처리에 시간이 걸리는 태스크를 실행할 경우,
블로킹(=작업 중단)(Blocking)이 발생함.
'''
function sleep(func, delay) {
    const delayUntil = Date.now() + delay;
    while(Date.now() < delayUntil);
    func();
}

function foo() { console.log('foo'); }
function bar() { console.log('bar'); }

sleep(foo, 3000);
bar();
'''
이처럼, 현재 실행 중인 태스크가 종료될 때까지 다음 태스크가 대기하는 것을
동기(Synchronous) 처리라고 함.

setTimeout 함수는 위의 sleep과 달리
일정 시간이 경과한 이후에 콜백 함수를 호출하지만,
setTimeout 함수 이후의 태스크를 블로킹하지 않고 곧바로 실행함.
이처럼, 현재 실행 중인 태스크가 종료되지 않아도
다음 태스크를 곧바로 실행하는 방식을 비동기(Asynchronous) 처리라고 함.
'''
function foo() { console.log('foo'); }
function bar() { console.log('bar'); }

setTimeout(foo, 3000);
bar();
'''

2.
비동기 처리를 수행하는 비동기 함수는 전통적으로 콜백 패턴을 사용함.
그러나 이는 콜백 헬을 발생시켜 가독성을 나쁘게 하고,
에러의 예외 처리를 어렵게 하며, 여러 비동기 처리를 한 번에 하는데 한계가 있음.

3.
타이머 함수인 setTimeout, setInterval, HTTP 요청, 이벤트 핸들러는
비동기 처리 방식으로 동작.
따라서, 비동기 처리는 이벤트 루프, 태스크 큐와 깊은 관계가 있음.

4.
자바스크립트의 동시성(concurrency)을 지원하는 것이 이벤트 루프(event loop).

5.
자바스크립트 엔진은 콜 스택과 힙으로 구성되어 있음.
태스그 요청 시 콜 스택을 통해 순차적으로 작업을 실행하고,
이 때 힙으로부터 객체를 참조함.

6.
비동기 처리에서 소스코드의 평가와 실행을 제외한 모든 처리는
자바스크립트 엔진을 구동하는 환경인 브라우저 또는 Node.js가 담당.
ex) setTimeout 내 콜백 함수의 평가와 실행은 자바스크립트 엔진이 담당하지만,
호출 스케줄링을 위한 타이머 설정, 콜백 함수 등록은 브라우저, Node.js가 담당.
이를 위해 브라우저에서는 태스크 큐와 이벤트 루프를 제공
(1) 태스크 큐(Task Queue)(= Event Queue, Callback Queue)
비동기 함수의 콜백 함수 또는 이벤트 핸들러가 일시적으로 보관되는 영역.
이와 별도로, 프로미스의 후속 처리 메서드의 콜백 함수가 일시적으로 보관되는
마이크로태스크 큐(Micro-task Queue)도 존재.

(2) 이벤트 루프(Event Loop)
콜 스택에 현재 실행 중인 실행 컨텍스트가 있는지,
태스크 큐에 대기 중인 함수(콜백 함수, 이벤트 핸들러 등)가 있는지 반복 확인.
콜 스택이 비어있고 태스크 큐에 대기 중인 함수가 있다면,
이벤트 루프는 순차적으로 태스크 큐에 대기 중인 함수를 콜 스택으로 이동시킴.

7.
비동기 함수인 setTimeout의 콜백 함수는 태스크 큐에 푸시되어 대기하다가
콜 스택이 비게 되면, 즉 전역 코드 및 명시적으로 호출된 함수가 모두 종료되면,
비로소 콜 스택에 푸시되어 실행됨.

8.
자바스크립트 엔진은 싱글 스레드로 동작하지만 브라우저는 멀티 스레드로 동작함.

9.
브라우저는 자바스크립트 엔진 이외에도 렌더링 엔진과 Web API를 제공.
Web API는 브라우저에서 제공하는 API이며
DOM API, 타이머 함수, HTTP 요청(Ajax)과 같은 비동기 처리를 포함함.
*/