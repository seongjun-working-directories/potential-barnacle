/*
1.
var는 블록레벨 스코프가 아닌 함수레벨 스코프를 지원.
이는 의도치 않게 전역 변수로 선언되어 심각한 부작용을 발생시킬 수 있음을 의미.

2.
변수 선언 이후 어떠한 값도 할당하지 않았다면,
해당 변수명이 가리키는 메모리 공간에는 undefined가 할당됨.
이렇게 암묵적으로 undefined를 할당할 경우, 변수를 사용자가 초기화하지 않아도
쓰레기값이 해당 주소값에 남아있지 않는 장점 존재.

3.
변수 이름을 비롯한 모든 식별자(함수명, 객체명 등)는 실행 컨텍스트에 등록됨.
여기서 실행 컨텍스트란, 자바스크립트 엔진이 소스코드를 평가하고 실행하기 위해
필요한 환경을 제공하고, 코드의 실행결과를 실제로 관리하는 영역.
실행 컨텍스트는 식별자와 스코프를 관리.
변수 이름과 변수 값은 실행 컨텍스트 내에 key-value 형식의 객체로 등록되어 관리.

4.
ReferenceError는 선언되지 않은 식별자에 접근하려할 때 발생하는 에러.

5.
자바스크립트 코드는 인터프리터에 의해 한 줄씩 순차적으로 해석.
따라서,
'''
console.log(score);
var score = 80;
'''
위의 코드를 실행할 경우, undefined가 출력됨.
ReferenceError가 아닌 undefined가 출력되는 이유는,
변수 선언이 런타임(소스코드가 한 줄씩 실행되는 시점)보다 이전 단계에서 실행되기 때문.
여기서 '이전 단계'란 소스코드 평가과정으로,
이때 소스코드의 모든 선언문(변수 선언, 함수 선언 등)을 찾아 먼저 실행함.
따라서, 런타임에는 선언문을 제외한 모든 소스코드가 한 줄씩 순차적으로 실행됨.

6.
자바스크립트 엔진은 변수 선언이 소스코드의 위치에 관계없이 다른 코드보다 먼저 실행됨.
이처럼, 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작(cf. 5번 참조)하는
자바스크립트 고유의 특징을 '변수 호이스팅'이라고 함.

7.
변수 선언 시점은 런타임(소스코드가 순차적으로 실행되는 시점) 이전이지만,
변수에 값을 할당하는 시점은 런타임임.

8.
다음과 같은 코드를 작성하면,
'''
console.log(score);
score=80;
var score;
console.log(score);
'''
결과값은 undefined 80이 됨.
이는 변수 호이스팅에 따라 var score라는 선언은 런타임 이전에 실행되었기 때문.

9.
5번의 코드를 보면 score는 undefined가 할당되었다가, 80이 할당됨.
이 때 score가 가리키는 메모리 주소에 존재하는 undefined가 지워지고,
80이 그 위에 써지는 게 아니고,
80이 다른 메모리에 80이란 값이 부여된 뒤, 해당 메모리로 score가 다시 가리킴.

10.
아무도 사용하지 않는 메모리값은 가비지 컬렉터에 의해 메모리에서 자동 해제됨.
즉, var score = 80; score = 90;을 할 경우,
score는 undefined->80->90이 되는데,
이 때 undefined와 80이 있는 주소값을 가리키는 변수는 없어지지만,
undefined, 80라는 값은 어떤 주소에 남아있음.
가비지 컬렉터는 어떤 식별자와도 연결되어 있지 않은 이 메모리 값을 정리함.
단, 메모리에서 언제 해제될지는 예측할 수 없음.
*/