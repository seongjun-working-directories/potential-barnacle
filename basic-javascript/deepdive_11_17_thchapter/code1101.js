/*
72.
자바스크립트의 객체는 프로퍼티 키를 인덱스로 사용하는
해시 테이블(hash table)의 성능 향상 버전.
cf. 해시 테이블(hash table)
해시 테이블은 (Key, Value)로 데이터를 저장하는 자료구조 중 하나로
빠르게 데이터를 검색할 수 있는 자료구조.
해시 테이블이 빠른 검색속도를 제공하는 이유는
내부적으로 배열(버킷)을 사용하여 데이터를 저장하기 때문.
해시 테이블은 각각의 Key값에 해시함수를 적용해 배열의 고유한 index를 생성하고,
이 index를 활용해 값을 저장하거나 검색하게 된다. 여기서 실제 값이 저장되는 장소를
버킷 또는 슬롯이라고 함.
즉, 해시 테이블 내부에서는 key와 bucket을 연결하는 통로가 있고
해당 통로는 hash function이라 불리는데,
이 hash function이 성능을 향상시키는데 사용됨.

73.
클래스 기반 객체지향 언어와 달리,
자바스크립트는 객체 생성 이후에도 동적으로 프로퍼티와 메서드를 추가할 수 있기 때문에,
성능면에서 생성과 프로퍼티 접근 비용이 더 많이 드는 비효율적인 방식임.
따라서, V8 자바스크립트 엔진은 프로퍼티에 접근하기 위해,
동적 탐색(dynamic lookup) 대신 히든 클래스(hidden class) 방식 사용해 성능 개선.

74.
히든 클래스(hidden class)란?
프로퍼티가 바뀔 때 각각 그 프로퍼티의 오프셋(주소값)을 업데이트한 뒤 그 값을 가지고 있는 방식.
히든 클래스(hidden class)의 특징은?
(1) 객체는 반드시 하나의 히든 클래스를 참조한다.
(2) 히든 클래스는 각 프로퍼티에 대해 메모리 오프셋을 가지고 있다.
(3) 동적으로 새로운 프로퍼티가 만들어질 때,
혹은 기존 프로퍼티가 삭제되거나 기존 프로퍼티의 데이터 타입이 바뀔 때는
신규 히든 클래스가 생성되며, 신규 히든 클래스는 기존 프로퍼티에 대한 정보를 유지하면서
추가적으로 새 프로퍼티의 오프셋을 가지게 된다.
(4) 히든 클래스는 프로퍼티에 대해 변경이 발생했을 때 참조해야 하는 히든 클래스에 대한 정보를 갖는다.
(5) 객체에 새로운 프로퍼티가 만들어지면, 현재 참조하고 있는 히든 클래스의 전환 정보를 확인한 후,
현재 프로퍼티에 대한 변경이 전환 정보의 조건과 일치하면,
객체의 참조 히든 클래스를 조건에 명시된 히든 클래스로 변경시킨다.

75.
동적 탐색(dynamic lookup)이란?
Static Typing언어는 type을 설정하는 순간
얼마만큼의 메모리가 할당되어야 하는지 정해지기 때문에 오프셋이 결정된다.
(길이가 정해지지 않은 배열이나 객체는 예외)
그러나 Dynamic Typing 언어는 이를 미리 결정할 수 없다
따라서 특정 객체의 property에 접근할때마다,
dynamic lookup을 통해 property를 스캔하여 찾아내야 한다.
이는 리소스 소모가 많이 드는 일이다.
(이러한 부분은 Prototype언어와 Class언어의 차이기도 하다.
Class언어라면 Class에 속한 객체들이 모두 같은 필드 구조를 가져 어떤 변수에 접근하고,
메모리는 어디인지 알 수 있다. 그러나 Prototype은 그것이 불가능하다.)

76.
객체는 원시값과 다르게 여러개의 식별자가 하나의 객체를 공유할 수 있음.

77.
얕은 복사(shallow copy)와 깊은 복사(deep copy)
객체의 관점에서 얕은 복사는 한 단계까지만 복사하는 것을 말하고,
깊은 복사는 객체에 중첩되어 있는 객체까지 복사하는 것을 의미.
'''
const o = { x: { y:1} };

// 얕은 복사
const copy1 = { ...o };		// "스프레드 문법"
console.log(copy1 === o);	// false
console.log(copy1.x === o.x);	// true

// 깊은 복사 : lodash의 cloneDeep 사용
const _ = require('lodash');
const copy2 = _.cloneDeep(o);
console.log(copy2 === o);	// false
console.log(copy2.x === o.x);	// false
'''
*/